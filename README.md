Программирование в школе и в университете. Ряд Фибоначчи. Оптимизация
=====================================================================

Я поступила на физический факультет, на специальность «Прикладные математика и физика», после зачисления нам было предложено выбрать группу (направление и руководящую кафедру), и я выбрала группу вычислительной физики и квантовых и магнитных явлений (то есть нашу группу курируют две кафедры).

У нас только два различных вида физики: лекции и практики, зато четыре разных информатики: лекции (введение в информатику), линукс, всякие программки (от Word до LaTeX и MatLab), программирование. Вот о нём я и хочу поговорить.

В школе мы, как и все детки, учились писать на Basic, Pascal, Delphi, в старших классах нам стали преподавать на C++, но, в общем-то, разрешили писать проектики и на других языках, которые нам больше нравятся. В университете нас жёстко ограничили: фортран. В школе у нас была [тестирующая система](http://school9.perm.ru/gate/), в университете на физфаке такого нет. В школе мы сдавали как можно больше задач на тестер, да и на олимпиадах тоже. Задача была придумать правильный алгоритм и аккуратно его реализовать, и решить так как можно больше задач. В университете, поскольку нет никакого тестера, мы пишем код, препод подходит и смотрит. И много внимания он уделяет оптимизации — тому, о чём в школе вообще речь не шла. Вот вам пример из жизни.

— Тема сегодняшнего урока: рекурсия, — препод обвёл взглядом группу. — Сегодня мы разберём её на примере ряда Фибоначчи.</p><p>Как известно, ряд Фибоначчи начинается с двух единиц, а каждый следующий член равен сумме двух предыдущих. То есть

> a<sub>1</sub>=1

> a<sub>2</sub>=1

> a<sub>n</sub>=a<sub>n-1</sub>+a<sub>n-2</sub>

Поэтому нам было предложено написать функцию, которая считает число Фибоначчи таким вот рекурсивным образом:
```fortran
integer(8) recursive function a(n) result (r)
    integer(8) :: n
    intent(in) :: n

    if (n > 2) then
        r = a(n-1) + a(n-2)
    else
        r = 1
    end if

    return
end function a
```

Видно, что мы считаем тут одно и то же сто тыщ миллионов раз. При счёте n-ного числа ряда мы считаем i-ое число <em>a<sub>n-i+1</sub></em> раз. То есть, например, при счёте 10-го числа мы считаем 9 и 10-е число 1 раз, 8-е 2 раза, 7-е 3 раза, 6-е 5 раз, 5-е 8 раз и т.д. При счёте 40-го числа мы обращаемся к 5-ому числу около 15 миллионов раз!

Заметим, что при вычислении <em>a<sub>n</sub></em> мы считаем a(n-2) два раза (непосредственно и считая <em>a<sub>n-1</sub></em>), поэтому мы можем смело утверждать, что
> a<sub>n</sub>=a<sub>n-2</sub>×2+a<sub>n-3</sub>

Что ж, напишем и такую функцию:
```fortran
integer(8) recursive function b(n) result (r)
    integer(8) :: n
    intent(in) :: n

    if (n > 2) then
        r = b(n-2)*2 + b(n-3)
    else if (n > 0) then
        r = 1
    else
        r = 0
    end if

    return
end function b
```

Здесь при расчёте 40-го числа мы посчитали 5-е всего лишь 8 тысяч раз. И наконец нам, ура-ура, предложили написать функцию без использования рекурсии, где каждое число мы считаем по одному разу:

```fortran
integer(8) function c(n)
    integer(8) :: n,i,x=0,y=1,z=1
    intent(in) :: n

    do, i=1, n-1
        z = x + y
        x = y
        y = z
    end do

    c = y

    return
end function c
```

Вот такие три функции мы написали. Понятно, что при расчёте даже 10-го числа разница в скорости незаметна, однако, например, при 50-ом числе мы можем наблюдать интересный результат (на моём компьютере, скомпилировано без оптимизации):

> 1 алгоритм: 77,21 секунды

> 2 алгоритм: 0,0056 секунды

> 3 алгоритм: 0,000001 секунды

— Когда есть возможность не использовать рекурсию, не используйте, — сказал препод. Раньше я писала программы так, как их удобно <em>писать</em>, совсем не задумываясь о том, как можно что-то оптимизировать и прочее. Теперь я всё время об этом думаю, и это хорошо.

